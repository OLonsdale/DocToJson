@page "/"

@using System.Text
@using System.Text.Json
@using Blazored.LocalStorage
@using Microsoft.AspNetCore.Components.Forms
@using DocToJson.Shared
@using DocToJson.Client.Services
@using DocToJson.Client.Data
@using DocToJson.Client.Components.SchemaBuilder

<PageTitle>Doc To JSON</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" >
    <MudToolBar>
        <MudText Typo="Typo.h5">Doc To JSON</MudText>
        <MudSpacer/>
        <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="ClearAll" Disabled="@isBusy"
                   EndIcon="@Icons.Material.Filled.Refresh">Reset All
        </MudButton>
    </MudToolBar>

    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">Instructions (Optional)</MudText>

        <MudPaper Class="pa-3">
            <MudTextField @bind-Value="prompt"
                          Label="Custom Prompt"
                          Placeholder="E.g. Calculate unit price if only line total + quantity provided"
                          Variant="Variant.Text"
                          Lines="3"
                          Clearable="true"/>
        </MudPaper>

        <MudText Typo="Typo.h6">Force output to conform to schema (Optional)</MudText>
        <SchemaBuilder @bind-Value="schema"/>

        <MudText Typo="Typo.h6">Select Files</MudText>

        <MudExpansionPanels MultiExpansion>
            <MudExpansionPanel Text="Upload & Actions" Expanded>
                <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                               @ref="fileUpload"
                               AppendMultipleFiles
                               OnFilesChanged="OnInputFilesChanged"
                               Hidden="false"
                               InputClass="absolute mud-width-full mud-height-full overflow-hidden z-10"
                               InputStyle="opacity:0"
                               Accept=".pdf,.docx,.doc,.csv,.txt,.xlsx,.xls,.json,.png,.jpg,.jpeg,.xml"
                               @ondragenter="SetDragClass"
                               @ondragleave="ClearDragClass"
                               @ondragend="ClearDragClass"
                               @ondrop="ClearDragClass">
                    <ActivatorContent>
                        <MudPaper Height="100px" Outlined="true" Class="@dragClass">
                            <MudText Typo="Typo.h6">Drop files here or click to select</MudText>
                        </MudPaper>
                    </ActivatorContent>
                </MudFileUpload>

                @if (files.Count > 0)
                {
                    foreach (var f in files)
                    {
                        <MudText>@(f.Name) (@(f.Size) bytes)</MudText>
                    }
                }

                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudSelect T="string" Value="@selectedModel" ValueChanged="OnSelectedModelChanged"
                               Label="Model" Dense="true" Variant="Variant.Outlined" Clearable="true">
                        @foreach (var m in models)
                        {
                            <MudSelectItem Value="@m">@m</MudSelectItem>
                        }
                    </MudSelect>
                </MudStack>

                <MudToolBar WrapContent Class="mt-2">
                    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SendAsync"
                               Disabled="@(files.Count == 0 || isBusy)" EndIcon="@Icons.Material.Filled.Send">
                        Send Request
                    </MudButton>

                    <MudButton Color="Color.Error" Variant="Variant.Outlined" OnClick="CancelRequest"
                               Disabled="@(!CanCancel)" StartIcon="@Icons.Material.Filled.Cancel">
                        Cancel
                    </MudButton>
                </MudToolBar>

                @if (isBusy)
                {
                    <MudProgressCircular Indeterminate Color="Color.Primary" Size="Size.Large" Class="mt-2"/>
                }
            </MudExpansionPanel>

            <MudExpansionPanel Text="Preview (first file)">
                @switch (preview)
                {
                    case PreviewType.Pdf:
                        <iframe src="@previewDataUrl" style="width:100%; height:75vh; border:none;"></iframe>
                        break;
                    case PreviewType.Image:
                        <img src="@previewDataUrl" style="max-width:100%; height:auto; border:0;" alt=""/>
                        break;
                    case PreviewType.Text:
                        <MudPaper Elevation="0" Class="pa-2">
                            <pre style="white-space:pre-wrap; margin:0">@previewText</pre>
                        </MudPaper>
                        break;
                    case PreviewType.Unsupported:
                        <MudAlert Severity="Severity.Info" Elevation="0">@previewMessage</MudAlert>
                        break;
                    default:
                        <MudText Color="Color.Secondary">No file selected.</MudText>
                        break;
                }
            </MudExpansionPanel>

            <MudText Typo="Typo.h6">Response</MudText>

            <MudExpansionPanel Expanded Text="Latest Result">
                @if (!string.IsNullOrEmpty(error))
                {
                    <MudAlert Severity="Severity.Error" Elevation="0">
                        <pre style="white-space:pre-wrap; margin:0">@Pretty(error)</pre>
                    </MudAlert>
                }
                @if (!string.IsNullOrEmpty(data))
                {
                    <MudPaper Elevation="0" Class="pa-2 mt-2">
                        <pre style="white-space:pre-wrap; margin:0">@Pretty(data)</pre>
                    </MudPaper>
                }

                @if (lastDetails is not null)
                {
                    <MudDivider Class="my-2" />
                    <MudText Typo="Typo.subtitle2">Run details</MudText>
                    <MudStack>
                        <MudText>Model: @lastDetails.Model</MudText>
                        <MudText>Tokens: in @lastDetails.InputTokens • out @lastDetails.OutputTokens • total @lastDetails.TotalTokens</MudText>
                        <MudText>Latency: @lastDetails.LatencyMs ms</MudText>
                        <MudText>Est. cost (USD): @lastDetails.EstimatedCostUsd.ToString("0.00000")</MudText>
                    </MudStack>
                }

                @if (lastUsage is not null)
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-2">Usage</MudText>
                    <MudText>Input: @lastUsage.InputTokens, Output: @lastUsage.OutputTokens, Total: @lastUsage.TotalTokens</MudText>
                }

                @if (lastFiles is not null && lastFiles.Length > 0)
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-2">Files</MudText>
                    <MudTable Items="lastFiles" Dense="true" Hover="true">
                        <HeaderContent>
                            <MudTh>File</MudTh>
                            <MudTh>Size (bytes)</MudTh>
                            <MudTh>File Id</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="File">@context.FileName</MudTd>
                            <MudTd DataLabel="Size">@context.SizeBytes</MudTd>
                            <MudTd DataLabel="File Id">@context.FileId</MudTd>
                        </RowTemplate>
                    </MudTable>
                }
            </MudExpansionPanel>

            <MudExpansionPanel Text="History">
                <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                    <MudSpacer/>
                    <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="ClearHistoryAsync"
                               Disabled="@(isBusy || history.Count == 0)" EndIcon="@Icons.Material.Filled.History">
                        Clear History
                    </MudButton>
                </MudStack>

                <MudExpansionPanels>
                    @foreach (var h in history)
                    {
                        <MudExpansionPanel>
                            <TitleContent>
                                <MudToolBar>
                                    <MudText>@h.Timestamp.ToString("yyyy-MM-dd HH:mm:ss"):</MudText>
                                    <MudText Class="ml-2">@string.Join(", ", h.FileNames)</MudText>
                                    <MudText Class="ml-2">@(
                                                          !string.IsNullOrWhiteSpace(h.SchemaValidationErrors) ? "Schema invalid" :
                                                          !string.IsNullOrWhiteSpace(h.SubmissionError) ? "Error" :
                                                          !string.IsNullOrWhiteSpace(h.ResponseJson) ? "Success" : "Blank"
                                                          )</MudText>
                                    <MudText Class="ml-2">$@h.Details?.EstimatedCostUsd</MudText>
                                    <MudText Class="ml-2">@h.Details?.Model</MudText>
                                    <MudText Class="ml-2">@(h.Details?.LatencyMs)ms</MudText>
                                    
                                    <MudSpacer/>
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error"
                                                   OnClick="@(() => DeleteHistoryAsync(h.Id))"/>
                                </MudToolBar>
                            </TitleContent>
                            <ChildContent>
                                <MudPaper Class="pa-3 my-2">
                                    <MudText Typo="Typo.subtitle2">Prompt</MudText>
                                    <pre style="white-space:pre-wrap; margin:0">@h.Prompt</pre>

                                    <MudText Typo="Typo.subtitle2" Class="mt-2">Schema</MudText>
                                    <pre style="white-space:pre-wrap; margin:0">@Pretty(h.Schema)</pre>

                                    @if (!string.IsNullOrWhiteSpace(h.SchemaValidationErrors))
                                    {
                                        <MudAlert Severity="Severity.Warning" Class="mt-2" Elevation="0">
                                            <pre style="white-space:pre-wrap; margin:0">@h.SchemaValidationErrors</pre>
                                        </MudAlert>
                                    }

                                    @if (!string.IsNullOrWhiteSpace(h.SubmissionError))
                                    {
                                        <MudAlert Severity="Severity.Error" Class="mt-2" Elevation="0">
                                            <pre style="white-space:pre-wrap; margin:0">@Pretty(h.SubmissionError)</pre>
                                        </MudAlert>
                                    }

                                    @if (h.Details is not null)
                                    {
                                        <MudDivider Class="my-2" />
                                        <MudText Typo="Typo.subtitle2">Run details</MudText>
                                        <MudStack>
                                            <MudText>Model: @h.Details.Model</MudText>
                                            <MudText>Tokens: in @h.Details.InputTokens • out @h.Details.OutputTokens • total @h.Details.TotalTokens</MudText>
                                            <MudText>Latency: @h.Details.LatencyMs ms</MudText>
                                            <MudText>Est. cost (USD): @h.Details.EstimatedCostUsd.ToString("0.00000")</MudText>
                                        </MudStack>
                                    }

                                    @if (h.Usage is not null)
                                    {
                                        <MudText Typo="Typo.subtitle2" Class="mt-2">Usage</MudText>
                                        <MudText>Input: @h.Usage.InputTokens, Output: @h.Usage.OutputTokens, Total: @h.Usage.TotalTokens</MudText>
                                    }

                                    @if (h.Files is not null && h.Files.Count > 0)
                                    {
                                        <MudText Typo="Typo.subtitle2" Class="mt-2">Files</MudText>
                                        <MudTable Items="h.Files" Dense="true" Hover="true">
                                            <HeaderContent>
                                                <MudTh>File</MudTh>
                                                <MudTh>Size (bytes)</MudTh>
                                                <MudTh>File Id</MudTh>
                                            </HeaderContent>
                                            <RowTemplate>
                                                <MudTd DataLabel="File">@context.FileName</MudTd>
                                                <MudTd DataLabel="Size">@context.SizeBytes</MudTd>
                                                <MudTd DataLabel="File Id">@context.FileId</MudTd>
                                            </RowTemplate>
                                        </MudTable>
                                    }

                                    @if (!string.IsNullOrWhiteSpace(h.ResponseJson))
                                    {
                                        <MudText Typo="Typo.subtitle2" Class="mt-2">Response</MudText>
                                        <MudPaper Class="pa-2">
                                            <pre style="white-space:pre-wrap; margin:0">@Pretty(h.ResponseJson)</pre>
                                        </MudPaper>
                                    }
                                </MudPaper>
                            </ChildContent>
                        </MudExpansionPanel>
                    }
                </MudExpansionPanels>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </MudStack>
</MudContainer>

@code {
    [Inject] ApiService Api { get; set; } = default!;
    [Inject] HistoryService History { get; set; } = default!;
    [Inject] ILocalStorageService LocalStorage { get; set; } = default!;

    MudFileUpload<IReadOnlyList<IBrowserFile>>? fileUpload;
    const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    string dragClass = DefaultDragClass;
    void SetDragClass() => dragClass = $"{DefaultDragClass} mud-border-primary";
    void ClearDragClass() => dragClass = DefaultDragClass;

    readonly List<IBrowserFile> files = new();
    IBrowserFile? FirstFile => files.FirstOrDefault();

    enum PreviewType { None, Pdf, Image, Text, Unsupported }

    List<string> models = [];
    string? selectedModel;

    protected override async Task OnInitializedAsync()
    {
        history = (await History.GetAllAsync()).ToList();
        selectedModel = await LocalStorage.GetItemAsStringAsync("SelectedModel");
        await LoadModels();
        if (string.IsNullOrWhiteSpace(selectedModel) && models.Count > 0)
            selectedModel = models.Contains("gpt-4.1-mini") ? "gpt-4.1-mini" : models[0];
        await LocalStorage.SetItemAsStringAsync("SelectedModel", selectedModel ?? string.Empty);
    }

    async Task LoadModels()
    {
        models = await Api.GetModelsAsync();
    }

    async Task OnSelectedModelChanged(string? value)
    {
        selectedModel = value;
        await LocalStorage.SetItemAsStringAsync("SelectedModel", selectedModel ?? string.Empty);
    }

    PreviewType preview = PreviewType.None;
    string? previewDataUrl;
    string? previewText;
    string? previewMessage;

    string prompt = string.Empty;
    string? schema;
    bool isBusy;
    CancellationTokenSource? requestCts;
    bool CanCancel => requestCts is not null && !requestCts.IsCancellationRequested;

    string? data;
    string? error;

    RunDetails? lastDetails;
    Usage? lastUsage;
    FileProvenance[]? lastFiles;

    List<HistoryEntry> history = new();

    async Task OnInputFilesChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        files.Clear();
        files.AddRange(e.GetMultipleFiles());
        await BuildPreviewAsync(FirstFile);
    }

    async Task BuildPreviewAsync(IBrowserFile? file)
    {
        if (file is null)
        {
            preview = PreviewType.None;
            previewDataUrl = previewText = previewMessage = null;
            StateHasChanged();
            return;
        }

        using var ms = new MemoryStream();
        await file.OpenReadStream().CopyToAsync(ms);
        var bytes = ms.ToArray();

        var ct = file.ContentType.Trim();
        var ext = Path.GetExtension(file.Name).ToLowerInvariant();

        if (ct == "application/pdf" || ext == ".pdf")
        {
            preview = PreviewType.Pdf;
            previewDataUrl = "data:application/pdf;base64," + Convert.ToBase64String(bytes);
            previewText = previewMessage = null;
        }
        else if (ct.StartsWith("image/"))
        {
            preview = PreviewType.Image;
            previewDataUrl = $"data:{ct};base64,{Convert.ToBase64String(bytes)}";
            previewText = previewMessage = null;
        }
        else if (IsTextLike(ct, ext))
        {
            preview = PreviewType.Text;
            previewText = DecodeText(bytes);
            previewDataUrl = previewMessage = null;
        }
        else
        {
            preview = PreviewType.Unsupported;
            previewDataUrl = previewText = null;
            previewMessage = $"Cannot preview {ext} files in the browser. They will still be sent for extraction.";
        }

        StateHasChanged();
    }

    static bool IsTextLike(string? contentType, string ext) =>
        (contentType?.StartsWith("text/") ?? false) ||
        contentType is "application/json" or "application/xml" ||
        ext is ".json" or ".xml" or ".csv" or ".txt";

    static string DecodeText(byte[] bytes)
    {
        try { return Encoding.UTF8.GetString(bytes); }
        catch { return "(unable to decode as UTF-8)"; }
    }

    static string Pretty(string? s)
    {
        if (string.IsNullOrWhiteSpace(s)) return s ?? "";
        try
        {
            using var doc = JsonDocument.Parse(s);
            return JsonSerializer.Serialize(doc.RootElement, new JsonSerializerOptions { WriteIndented = true });
        }
        catch { return s; }
    }

    void ClearResult()
    {
        data = null;
        error = null;
        lastDetails = null;
        lastUsage = null;
        lastFiles = null;
    }

    async Task ClearAll()
    {
        files.Clear();
        if (fileUpload is not null) await fileUpload.ClearAsync();

        preview = PreviewType.None;
        previewDataUrl = previewText = previewMessage = null;
        prompt = string.Empty;
        schema = null;
        ClearResult();
    }

    void CancelRequest()
    {
        try { requestCts?.Cancel(); }
        catch (Exception ex) { Console.WriteLine(ex.Message); }
    }

    async Task SendAsync()
    {
        if (files.Count == 0 || requestCts is not null) return;

        isBusy = true;
        ClearResult();
        requestCts = new CancellationTokenSource();
        var ct = requestCts.Token;

        var entry = new HistoryEntry
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTimeOffset.Now,
            FileNames = files.Select(f => f.Name).ToList(),
            Prompt = prompt,
            Schema = schema
        };

        try
        {
            if (!string.IsNullOrWhiteSpace(schema) && !ValidateSchemaStrict(schema!, out var errs))
            {
                entry.SchemaValidationErrors = errs;
                error = "Schema invalid. See history for details.";
                await PushHistoryAsync(entry);
                return;
            }

            var fileParts = new List<FilePart>(this.files.Count);
            foreach (var f in this.files)
            {
                using var ms = new MemoryStream();
                await f.OpenReadStream().CopyToAsync(ms, ct);
                fileParts.Add(new FilePart { FileName = f.Name, Bytes = ms.ToArray() });
            }

            var payload = new DocumentExtractionRequest
            {
                Prompt = prompt,
                Files = fileParts,
                JsonSchema = string.IsNullOrWhiteSpace(schema) ? null : schema,
                SchemaName = "schema",
                Model = selectedModel
            };

            var body = await Api.ExtractAsync(payload, ct);

            if (body is null)
            {
                const string httpErr = "No response body.";
                error = httpErr;
                entry.SubmissionError = httpErr;
                await PushHistoryAsync(entry);
                return;
            }

            if (body.IsError)
            {
                error = body.Error;
                entry.SubmissionError = body.Error;
                await PushHistoryAsync(entry);
                return;
            }

            data = body.Data;
            lastDetails = body.Details;
            lastUsage = body.Usage;
            lastFiles = body.Files;

            entry.ResponseJson = body.Data;
            entry.Details = body.Details;
            entry.Usage = body.Usage;
            entry.Files = body.Files?.ToList();

            await PushHistoryAsync(entry);
        }
        catch (OperationCanceledException)
        {
            error = "Request cancelled.";
            entry.SubmissionError = "Request cancelled.";
            await PushHistoryAsync(entry);
        }
        catch (Exception ex)
        {
            error = ex.Message;
            entry.SubmissionError = ex.Message;
            await PushHistoryAsync(entry);
        }
        finally
        {
            requestCts?.Dispose();
            requestCts = null;
            isBusy = false;
            StateHasChanged();
        }
    }

    async Task PushHistoryAsync(HistoryEntry e)
    {
        await History.AddAsync(e);
        history = (await History.GetAllAsync()).ToList();
        StateHasChanged();
    }

    async Task ClearHistoryAsync()
    {
        await History.ClearAsync();
        history.Clear();
    }

    async Task DeleteHistoryAsync(Guid id)
    {
        await History.DeleteAsync(id);
        history = (await History.GetAllAsync()).ToList();
        StateHasChanged();
    }

    static bool ValidateSchemaStrict(string schemaJson, out string errors)
    {
        var sb = new StringBuilder();
        try
        {
            using var doc = JsonDocument.Parse(schemaJson);
            var root = doc.RootElement;

            if (root.ValueKind != JsonValueKind.Object)
            {
                errors = "Root must be a JSON object.";
                return false;
            }

            if (!root.TryGetProperty("properties", out var propsEl) || propsEl.ValueKind != JsonValueKind.Object)
            {
                errors = "Schema must contain a 'properties' object.";
                return false;
            }

            var propNames = propsEl.EnumerateObject().Select(p => p.Name).ToArray();

            if (!root.TryGetProperty("required", out var reqEl) || reqEl.ValueKind != JsonValueKind.Array)
            {
                errors = "'required' must be an array including every key in 'properties'.";
                return false;
            }

            var requiredNames = new HashSet<string>(StringComparer.Ordinal);
            foreach (var item in reqEl.EnumerateArray())
            {
                if (item.ValueKind != JsonValueKind.String)
                {
                    errors = "'required' must only contain strings.";
                    return false;
                }
                requiredNames.Add(item.GetString()!);
            }

            var missing = propNames.Where(p => !requiredNames.Contains(p)).ToArray();
            if (missing.Length > 0)
            {
                sb.AppendLine("The 'required' array is missing the following properties:");
                foreach (var m in missing) sb.AppendLine($" - {m}");
            }

            if (!root.TryGetProperty("additionalProperties", out var apEl) || apEl.ValueKind != JsonValueKind.False)
                sb.AppendLine("(Note) For strict output, set 'additionalProperties': false.");

            errors = sb.ToString().Trim();
            return string.IsNullOrEmpty(errors) || errors.StartsWith("(Note)");
        }
        catch (JsonException jx)
        {
            errors = $"Schema is not valid JSON: {jx.Message}";
            return false;
        }
        catch (Exception ex)
        {
            errors = $"Schema validation failed: {ex.Message}";
            return false;
        }
    }
}
