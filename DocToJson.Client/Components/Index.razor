@page "/"
@using DocToJson.Client.Components.SchemaBuilder
@* Claims not to need this, but does *@

<PageTitle>Doc to JSON</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge">
    <MudToolBar Gutters="false">
        <MudFab OnClick="@ToggleDark" EndIcon="@Icons.Material.Filled.Brightness6"/>
        <MudSpacer/>
        <MudText Typo="Typo.h5">Doc to JSON</MudText>
        <MudSpacer/>
        <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="@ClearAll" Disabled="@isBusy"
                   EndIcon="@Icons.Material.Filled.Refresh">Reset All
        </MudButton>
    </MudToolBar>

    <MudExpansionPanels MultiExpansion>

        <MudExpansionPanel Expanded>
            <TitleContent>
                <MudText Typo="Typo.h6">Instructions (Optional)</MudText>
            </TitleContent>
            <ChildContent>
                <MudTextField @bind-Value="prompt"
                              Label="Custom Prompt"
                              Placeholder="E.g. Calculate unit price if only line total + quantity provided"
                              Variant="Variant.Outlined"
                              Lines="3"
                              Clearable/>
            </ChildContent>
        </MudExpansionPanel>

        <MudExpansionPanel Expanded>
            <TitleContent>
                <MudText Typo="Typo.h6">Force output to conform to schema (Optional)</MudText>
            </TitleContent>
            <ChildContent>
                <MudSelect T="string" Value="@selectedModel" ValueChanged="OnSelectedModelChanged"
                           Label="Model" Dense Variant="Variant.Outlined">
                    @foreach (var m in models)
                    {
                        <MudSelectItem Value="@m">@m</MudSelectItem>
                    }
                </MudSelect>
            </ChildContent>
        </MudExpansionPanel>
        
        <MudExpansionPanel Expanded>
            <TitleContent>
                <MudText Typo="Typo.h6">JSON Schema (Optional)</MudText>
                <MudText Typo="Typo.caption">Use this to enforce a specific output format </MudText>
            </TitleContent>
            <ChildContent>
                <SchemaBuilder @bind-Value="schema"/>
            </ChildContent>
        </MudExpansionPanel>
        
        <MudExpansionPanel Expanded>
            <TitleContent>
                <MudText Typo="Typo.h6">Select Files</MudText>
            </TitleContent>
            <ChildContent>
                <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                               @ref="fileUpload"
                               AppendMultipleFiles
                               OnFilesChanged="OnInputFilesChanged"
                               Hidden="false"
                               InputClass="absolute mud-width-full mud-height-full overflow-hidden z-10"
                               InputStyle="opacity:0"
                               Accept=".pdf,.docx,.doc,.csv,.txt,.xlsx,.xls,.json,.png,.jpg,.jpeg,.xml"
                               @ondragenter="@SetDragClass"
                               @ondragleave="@ClearDragClass"
                               @ondragend="ClearDragClass"
                               @ondrop="ClearDragClass">
                    <ActivatorContent>
                        <MudPaper Height="100px" Outlined Class="@dragClass">
                            <MudText Typo="Typo.h6">Drop files here or click to select</MudText>
                        </MudPaper>
                    </ActivatorContent>
                </MudFileUpload>

                @foreach (var f in files)
                {
                    <MudText Style="font-weight: bold">@(f.Name) (@(f.Size) bytes)</MudText>
                }

                <MudExpansionPanels>
                    <MudExpansionPanel Text="Preview File/s">
                        <DocumentPreview Files="files" Height="75vh"/>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            </ChildContent>
        </MudExpansionPanel>
        
        <MudToolBar WrapContent Class="mt-2" Gutters="false">
            <MudButton Color="Color.Success" Variant="Variant.Filled" OnClick="@SendExtractRequestAsync"
                       Disabled="@(files.Count == 0 || isBusy)" EndIcon="@Icons.Material.Filled.Send">
                GO!
            </MudButton>

            <MudButton Color="Color.Error" Variant="Variant.Outlined" OnClick="@CancelRequest"
                       Disabled="@(!CanCancel)" StartIcon="@Icons.Material.Filled.Cancel">
                Cancel
            </MudButton>
        </MudToolBar>

        @if (isBusy)
        {
            <MudProgressCircular Indeterminate Color="Color.Primary" Size="Size.Large" Class="mt-2 mb-2"/>
        }

        <MudText Typo="Typo.h6">Response</MudText>

        @if (error.IsNotNullOrEmpty() || data.IsNotNullOrEmpty())
        {
            <LatestResultPanel
                Error="@error"
                Data="@data"
                Details="lastDetails"
                Usage="lastUsage"
                Files="lastFiles"/>
        }

        <MudExpansionPanel Text="History">
            <HistoryComponent Busy="isBusy"/>
        </MudExpansionPanel>
    </MudExpansionPanels>

</MudContainer>

@code {
    [Inject] ApiService Api { get; set; } = null!;
    [Inject] HistoryService History { get; set; } = null!;
    [Inject] ILocalStorageService LocalStorage { get; set; } = null!;

    [CascadingParameter] public Action ToggleDark { get; set; } = null!;

    MudFileUpload<IReadOnlyList<IBrowserFile>>? fileUpload;
    const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    string dragClass = DefaultDragClass;
    void SetDragClass() => dragClass = $"{DefaultDragClass} mud-border-primary";
    void ClearDragClass() => dragClass = DefaultDragClass;

    readonly List<IBrowserFile> files = new();

    List<string> models = [];
    string? selectedModel;

    protected override async Task OnInitializedAsync()
    {
        selectedModel = await LocalStorage.GetItemAsStringAsync("SelectedModel");
        await LoadModels();
        if (string.IsNullOrWhiteSpace(selectedModel) && models.Count > 0)
            selectedModel = models.Contains("gpt-4.1-mini") ? "gpt-4.1-mini" : models[0];
        await LocalStorage.SetItemAsStringAsync("SelectedModel", selectedModel ?? string.Empty);
    }

    async Task LoadModels() => models = await Api.GetModelsAsync();

    async Task OnSelectedModelChanged(string? value)
    {
        selectedModel = value;
        await LocalStorage.SetItemAsStringAsync("SelectedModel", selectedModel ?? string.Empty);
    }

    string prompt = string.Empty;
    string? schema;
    bool isBusy;
    CancellationTokenSource? requestCts;
    bool CanCancel => requestCts is not null && !requestCts.IsCancellationRequested;

    string? data;
    string? error;

    RunDetails? lastDetails;
    Usage? lastUsage;
    FileProvenance[]? lastFiles;

    async Task OnInputFilesChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        files.Clear();
        files.AddRange(e.GetMultipleFiles());
        StateHasChanged();
    }

    void ClearResult()
    {
        data = null;
        error = null;
        lastDetails = null;
        lastUsage = null;
        lastFiles = null;
    }

    async Task ClearAll()
    {
        files.Clear();
        if (fileUpload is not null) await fileUpload.ClearAsync();

        prompt = string.Empty;
        schema = null;
        ClearResult();
    }

    void CancelRequest()
    {
        try
        {
            requestCts?.Cancel();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }

    async Task SendExtractRequestAsync()
    {
        if (files.Count == 0 || requestCts is not null) return;

        isBusy = true;
        ClearResult();
        requestCts = new CancellationTokenSource();
        var ct = requestCts.Token;

        var entry = new HistoryEntry
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTimeOffset.Now,
            FileNames = files.Select(f => f.Name).ToList(),
            Prompt = prompt,
            Schema = schema
        };

        try
        {
            if (!string.IsNullOrWhiteSpace(schema) && !ValidateSchemaStrict(schema!, out var errs))
            {
                entry.SchemaValidationErrors = errs;
                error = "Schema invalid. See history for details.";
                await PushHistoryAsync(entry);
                return;
            }

            var fileParts = new List<FilePart>(files.Count);
            foreach (var f in files)
            {
                using var ms = new MemoryStream();
                await f.OpenReadStream().CopyToAsync(ms, ct);
                fileParts.Add(new FilePart { FileName = f.Name, Bytes = ms.ToArray() });
            }

            var payload = new DocumentExtractionRequest
            {
                Prompt = prompt,
                Files = fileParts,
                JsonSchema = string.IsNullOrWhiteSpace(schema) ? null : schema,
                SchemaName = "schema",
                Model = selectedModel
            };

            var body = await Api.ExtractAsync(payload, ct);

            if (body is null)
            {
                const string httpErr = "No response body.";
                error = httpErr;
                entry.SubmissionError = httpErr;
                await PushHistoryAsync(entry);
                return;
            }

            if (body.IsError)
            {
                error = body.Error;
                entry.SubmissionError = body.Error;
                await PushHistoryAsync(entry);
                return;
            }

            data = body.Data;
            lastDetails = body.Details;
            lastUsage = body.Usage;
            lastFiles = body.Files;

            entry.ResponseJson = body.Data;
            entry.Details = body.Details;
            entry.Usage = body.Usage;
            entry.Files = body.Files?.ToList();

            await PushHistoryAsync(entry);
        }
        catch (OperationCanceledException)
        {
            error = "Request cancelled.";
            entry.SubmissionError = "Request cancelled.";
            await PushHistoryAsync(entry);
        }
        catch (Exception ex)
        {
            error = ex.Message;
            entry.SubmissionError = ex.Message;
            await PushHistoryAsync(entry);
        }
        finally
        {
            requestCts?.Dispose();
            requestCts = null;
            isBusy = false;
            StateHasChanged();
        }
    }

    async Task PushHistoryAsync(HistoryEntry e)
    {
        await History.AddAsync(e);
        StateHasChanged();
    }

    static bool ValidateSchemaStrict(string schemaJson, out string errors)
    {
        var sb = new StringBuilder();
        try
        {
            using var doc = JsonDocument.Parse(schemaJson);
            var root = doc.RootElement;

            if (root.ValueKind != JsonValueKind.Object)
            {
                errors = "Root must be a JSON object.";
                return false;
            }

            if (!root.TryGetProperty("properties", out var propsEl) || propsEl.ValueKind != JsonValueKind.Object)
            {
                errors = "Schema must contain a 'properties' object.";
                return false;
            }

            var propNames = propsEl.EnumerateObject().Select(p => p.Name).ToArray();

            if (!root.TryGetProperty("required", out var reqEl) || reqEl.ValueKind != JsonValueKind.Array)
            {
                errors = "'required' must be an array including every key in 'properties'.";
                return false;
            }

            var requiredNames = new HashSet<string>(StringComparer.Ordinal);
            foreach (var item in reqEl.EnumerateArray())
            {
                if (item.ValueKind != JsonValueKind.String)
                {
                    errors = "'required' must only contain strings.";
                    return false;
                }

                requiredNames.Add(item.GetString()!);
            }

            var missing = propNames.Where(p => !requiredNames.Contains(p)).ToArray();
            if (missing.Length > 0)
            {
                sb.AppendLine("The 'required' array is missing the following properties:");
                foreach (var m in missing) sb.AppendLine($" - {m}");
            }

            if (!root.TryGetProperty("additionalProperties", out var apEl) || apEl.ValueKind != JsonValueKind.False)
                sb.AppendLine("(Note) For strict output, set 'additionalProperties': false.");

            errors = sb.ToString().Trim();
            return string.IsNullOrEmpty(errors) || errors.StartsWith("(Note)");
        }
        catch (JsonException jx)
        {
            errors = $"Schema is not valid JSON: {jx.Message}";
            return false;
        }
        catch (Exception ex)
        {
            errors = $"Schema validation failed: {ex.Message}";
            return false;
        }
    }

}
